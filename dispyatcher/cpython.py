import ctypes
from typing import Sequence, Dict, Union, List, NamedTuple, Callable

import llvmlite.ir
from llvmlite.ir import IRBuilder, Value as IRValue, Type as LLType, Block

import dispyatcher
from dispyatcher import Type, Handle, llvm_type_to_ctype
from dispyatcher.repacking import RepackingDispatcher, Repacker
from dispyatcher.resource import ResourceHandle


class _PyObjectType(Type):

    def ctypes_type(self):
        return ctypes.py_object

    def machine_type(self) -> LLType:
        return llvmlite.ir.PointerType(llvmlite.ir.IntType(8))

    def __str__(self) -> str:
        return "PyObject"


PY_OBJECT_TYPE = _PyObjectType()
""" The type for an unknown Python object (in C, `PyObject*`) """


class CFunctionHandle(Handle):
    """
    Wraps a `ctypes` generated function in a handle
    """
    __args: Sequence[Type]
    __ret: Type

    def __init__(self, ret: Type, cfunc, *args: Type, ignore_return_type=False):
        """
        Creates a new wrapper around a ctype function.

        There is not necessarily enough information in ctypes to accurate check that the function is being called with
        the correct argument types. This is some very C unsafe behaviour. If the argument types are filled out in the
        ctypes function, which they are often not, this will attempt to validate them against arguments provided. If
        no arguments are known in the ctypes function, YOLO.
        :param ret: the return type of this function; since this must be filled out, this will always be checked
        :param cfunc: the ctypes function to call
        :param args: the parameters types to the function
        """
        super().__init__()
        self.__cfunc = cfunc
        self.__args = args
        self.__ret = ret
        if not ignore_return_type:
            machine_restype = llvm_type_to_ctype(ret.machine_type())
            assert machine_restype == cfunc.restype,\
                f"ctype function result {cfunc.restype} not compatible with specified return type {machine_restype}"
        if cfunc.argtypes:
            assert len(cfunc.argtypes) == len(args),\
                f"Argument lengths don't match. Got {len(args)}, ctypes expected {len(cfunc.argtypes)}."
            for index, (cfunc_arg, arg_type) in enumerate(zip(cfunc.argtypes, args)):
                assert llvm_type_to_ctype(arg_type.machine_type()) == cfunc_arg, \
                    f"Argument {index} is expected to be {cfunc_arg}, but got {arg_type}."

    def function_type(self) -> (Type, Sequence[Type]):
        return self.__ret, self.__args

    def generate_ir(self, builder: IRBuilder, args: Sequence[IRValue],
                    global_addresses: Dict[str, ctypes.c_char_p]) -> IRValue:
        fn_name = builder.module.get_unique_name("cfunc")
        fn_type = llvmlite.ir.FunctionType(self.__ret.machine_type(), (arg.machine_type() for arg in self.__args))
        fn = llvmlite.ir.GlobalVariable(builder.module, fn_type.as_pointer(), fn_name)
        fn.initializer = llvmlite.ir.Constant(fn_type.as_pointer(), llvmlite.ir.Undefined)
        global_addresses[fn_name] = ctypes.c_char_p.from_address(ctypes.addressof(self.__cfunc))
        return builder.call(builder.load(fn), args)

    def __str__(self) -> str:
        return f"CType {self.__cfunc}"


class TupleArguments(NamedTuple):
    """
    The LLVM IR values needed to unpack a tuple

    Some arguments must be pre-allocated and passed to the `PyArg_ParseTuple` function and some must be passed to the
    handle that will consume the results, if successful.
    """
    unpack_args: Sequence[llvmlite.ir.Value]
    call_args: Callable[[], Sequence[llvmlite.ir.Value]]


class TupleElement:
    """ A representation of a possible type inside a tuple that `PyArg_ParseTuple` can use"""

    def format_code(self) -> str:
        """The code that directs the `packing/unpacking of a tuple
        <https://septatrix.github.io/cpython-dark-docs/c-api/arg.html#parsing-arguments>`_."""
        pass

    def pack(self) -> int:
        """
        The number of input arguments that will be consumed when packing
        :return: the argument count
        """
        pass

    def unpack(self, builder: IRBuilder) -> TupleArguments:
        """
        Prepares a tuple for unpacking

        This creates allocations for the arguments to a tuple unpacking and a callback that allows generating loading
        those arguments. As a general rule, tuple unpacking requires a pointer to a storage location (one that will
        likely be generated by `alloca` and then loading that location so it can be used in the target handle. This
        function creates an instructions for the `alloca` instructions and then provides a callback to load them when
        required, in the same builder. Some single tuple elements translate to multiple real arguments (_e.g._, data +
        length for buffers) and a tuple element represents on logical element even if it requires multiple arguments
        :param builder:  the LLVM IR builder in which to generate code
        :return: the argument information required
        """
        pass


class SimpleTupleElement(TupleElement):
    """
    A naive tuple element that has a 1:1 correspondence between element and argument and can be created by an `alloc`.
    """
    __format: str
    __type: llvmlite.ir.Type

    def __init__(self, format_code: str, ty: llvmlite.ir.Type):
        """
        Create a new naive tuple element
        :param format_code: the Python format code to use
        :param ty: the type of the element; the machine type must match the format code, but it will not be checked
        """
        super().__init__()
        self.__format = format_code
        self.__type = ty

    def format_code(self) -> str:
        return self.__format

    def pack(self) -> int:
        return 1

    def unpack(self, builder: IRBuilder) -> TupleArguments:
        alloc = builder.alloca(self.__type)
        return TupleArguments(unpack_args=(alloc,), call_args=lambda: (builder.load(alloc),))


class TupleUnpackingDispatcher(RepackingDispatcher[None]):
    """
    A dispatcher that knows how to unpack a Python tuple into multiple arguments
    """
    def __init__(self, fallback: Handle, tuple_index: int):
        """
        Construct a new handle
        :param fallback: the handle to use if the input does not match
        :param tuple_index: the index in the fallback argument list where the tuple, as a `PY_OBJECT_TYPE`, will occur
        """
        super().__init__(fallback, tuple_index)
        assert fallback.function_type()[1][tuple_index] == PY_OBJECT_TYPE,\
            "First common argument is not a Python object"

    def _find_repack(self, input_args: Sequence[Type], output_args: Sequence[Type], hint: None)\
            -> Union[Repacker, None]:
        tuple_args = [find_unpack(arg) for arg in output_args[0:len(output_args) - len(input_args) + 1]]
        return _TupleUnpacker(tuple_args)


class _TupleUnpacker(Repacker):
    __elements: List[TupleElement]

    def __init__(self, element: List[TupleElement]):
        super().__init__()
        self.__elements = element

    def input_count(self) -> int:
        return 1

    def output_count(self) -> int:
        return len(self.__elements)

    def generate_ir(self, builder: IRBuilder, args: Sequence[IRValue], failure_block: Block,
                    global_addresses: Dict[str, ctypes.c_char_p]) -> Sequence[IRValue]:
        i8 = llvmlite.ir.IntType(8)
        i32 = llvmlite.ir.IntType(32)
        (arg, ) = args
        outputs = []
        fmt_code = "".join(element.format_code() for element in self.__elements).encode("utf-8") + b"\x00"
        fmt_const = llvmlite.ir.Constant(llvmlite.ir.ArrayType(i8, len(fmt_code)), bytearray(fmt_code))
        fmt_global = llvmlite.ir.GlobalVariable(builder.module, fmt_const.type,
                                                builder.module.get_unique_name("tuple_format"))
        fmt_global.initializer = fmt_const
        fmt_global.global_constant = True
        unpack_args = [arg, builder.bitcast(fmt_global, i8.as_pointer())]
        for element in self.__elements:
            element_args = element.unpack(builder)
            outputs.append(element_args.call_args)
            unpack_args.extend(element_args.unpack_args)

        if "PyArg_ParseTuple" in builder.module.globals:
            fn = builder.module.globals["PyArg_ParseTuple"]
        else:
            fn_type = llvmlite.ir.FunctionType(i32,
                                               [PY_OBJECT_TYPE.machine_type(), llvmlite.ir.IntType(8).as_pointer()],
                                               var_arg=True)
            fn = llvmlite.ir.GlobalVariable(builder.module, fn_type.as_pointer(), "PyArg_ParseTuple")
            fn.initializer = llvmlite.ir.Constant(fn_type.as_pointer(), llvmlite.ir.Undefined)
            global_addresses["PyArg_ParseTuple"] = ctypes.c_char_p.from_address(
                ctypes.addressof(ctypes.pythonapi.PyArg_ParseTuple))
        comparison = builder.icmp_unsigned("==", builder.call(builder.load(fn), unpack_args), i32(0))
        success_block = builder.append_basic_block("tuple_unpacked")
        builder.cbranch(comparison, failure_block, success_block)

        builder.position_at_end(failure_block)
        if "PyErr_Clear" in builder.module.globals:
            clear_fn = builder.module.globals["PyErr_Clear"]
        else:
            clear_fn_type = llvmlite.ir.FunctionType(llvmlite.ir.VoidType(), [])
            clear_fn = llvmlite.ir.GlobalVariable(builder.module, clear_fn_type.as_pointer(), "PyErr_Clear")
            clear_fn.initializer = llvmlite.ir.Constant(clear_fn_type.as_pointer(), llvmlite.ir.Undefined)
            global_addresses["PyErr_Clear"] = ctypes.c_char_p.from_address(
                ctypes.addressof(ctypes.pythonapi.PyErr_Clear))
        builder.call(builder.load(clear_fn), [])

        builder.position_at_end(success_block)
        output_values = [o for output in outputs for o in output()]
        print(output_values)
        return output_values

    def __str__(self) -> str:
        return "Tuple " + "".join(element.format_code() for element in self.__elements)


INT_TUPLE_ELEMENT = {
    8: SimpleTupleElement("b", llvmlite.ir.IntType(8)),
    16: SimpleTupleElement("h", llvmlite.ir.IntType(16)),
    32: SimpleTupleElement("i", llvmlite.ir.IntType(32)),
    64: SimpleTupleElement("l", llvmlite.ir.IntType(64)),
    128: SimpleTupleElement("L", llvmlite.ir.IntType(128)),
}
INT_TUPLE_ELEMENT_ALLOW_OVERFLOW = {
    8: SimpleTupleElement("B", llvmlite.ir.IntType(8)),
    16: SimpleTupleElement("H", llvmlite.ir.IntType(16)),
    32: SimpleTupleElement("I", llvmlite.ir.IntType(32)),
    64: SimpleTupleElement("k", llvmlite.ir.IntType(64)),
    128: SimpleTupleElement("K", llvmlite.ir.IntType(128)),
}

CHAR_TUPLE_ELEMENT = SimpleTupleElement("c", llvmlite.ir.IntType(8))
UNICHAR_TUPLE_ELEMENT = SimpleTupleElement("C", llvmlite.ir.IntType(32))
FLOAT_TUPLE_ELEMENT = SimpleTupleElement("f", llvmlite.ir.FloatType())
DOUBLE_TUPLE_ELEMENT = SimpleTupleElement("d", llvmlite.ir.DoubleType())

PY_OBJECT_TUPLE_ELEMENT = SimpleTupleElement("O", PY_OBJECT_TYPE.machine_type())


def find_unpack(ty: Type) -> TupleElement:
    """
    Attempts to find a tuple element that matches an arbitrary type

    If the type implements `TupleElement`, then it will be used as itself. Otherwise, if the type has a numeric machine
    type, an appropriate tuple element based on that machine type will be used.
    :param ty: the type to find a matching tuple element representation of
    :return: the best match, if found, otherwise, a `ValueError` will be raised.
    """
    if isinstance(ty, TupleElement):
        return ty
    if ty == PY_OBJECT_TYPE:
        return PY_OBJECT_TUPLE_ELEMENT
    if isinstance(ty.machine_type(), llvmlite.ir.IntType):
        return INT_TUPLE_ELEMENT[ty.machine_type().width]
    if isinstance(ty.machine_type(), llvmlite.ir.FloatType):
        return FLOAT_TUPLE_ELEMENT
    if isinstance(ty.machine_type(), llvmlite.ir.DoubleType):
        return DOUBLE_TUPLE_ELEMENT
    raise ValueError(f"No tuple conversion for {ty}")


class _GlobalInterpreterLockType(Type):

    def ctypes_type(self):
        raise ValueError("Absolutely refusing to leak a Python Interpreter Lock into Python. You will have a bad time.")

    def machine_type(self) -> LLType:
        return llvmlite.ir.IntType(32)

    def __str__(self) -> str:
        return "PythonGIL"


GIL_TYPE = _GlobalInterpreterLockType()
GIL_STATE_ENSURE_HANDLE = CFunctionHandle(GIL_TYPE, ctypes.pythonapi.PyGILState_Ensure)
GIL_STATE_RELEASE_HANDLE = CFunctionHandle(dispyatcher.MachineType(llvmlite.ir.VoidType()),
                                           ctypes.pythonapi.PyGILState_Release, GIL_TYPE, ignore_return_type=True)


def with_gil(inner: Handle) -> Handle:
    """
    Wraps a handle so that the Python GIL will be acquired before the handle is executed and released after.
    :param inner: the handle to wrap
    :return: the GIL-protected handle
    """
    return ResourceHandle(inner, None, GIL_STATE_ENSURE_HANDLE, GIL_STATE_RELEASE_HANDLE)
